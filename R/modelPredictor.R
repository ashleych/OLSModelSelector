#' Forecast values using chosen model
#'
#' @param selectedModel model name as a string as generated by the function modelDeveloper. String can be stored in a vector and used as well
#' @param allModelEvaluated the results as generated by modelEvaluator function
#' @return Returns a dataframe with predicted values
#' @export
#' @examples
#' selectedModelForecaster(selectedModel,allModelEvaluated)

selectedModelForecaster <- function(selectedModel,selectedModelObject,allModelEvaluated,...){
  
  used_vars <- trimws(unlist(strsplit(selectedModel,"[+,~]")))
  keep_vars<- c("Date",used_vars,"predicted_values")
  
  input_arg_list <- list(...)
  if ("scenario_input_df" %in% names(input_arg_list)) {

    predicted_values <- predict(selectedModelObject,newdata = input_arg_list$scenario_input_df)
    
    predicted_df <- data.table(cbind(input_arg_list$scenario_input_df,predicted_values))[,..keep_vars]
  } 
  else {
    #allModelEvaluated is not needed, to remove from this function as well as charter
    predicted_values <- predict(selectedModelObject,newdata = forecast_df)
    
    predicted_df <- data.table(cbind(forecast_df,predicted_values))[,..keep_vars]
    
  }

  return(predicted_df)
}



#' Chart the model selected
#'
#' @param selectedModel model name as a string as generated by the function modelDeveloper. String can be stored in a vector and used as well
#' @param allModelEvaluated the results as generated by modelEvaluator function
#' @return Returns ggplot
#' @export
#' @examples
#' selectedModelForecaster(selectedModel,allModelEvaluated)

selectedModelCharter <- function(selectedModel, selectedModelObject,allModelEvaluated,...) {
  #input_list <- as.list(substitute(list(...)))
  input_list <- list(...)
  if ("predicted_df" %in% names(input_list) &&
      "data.frame" %in% class(input_list$predicted_df) &&
      nrow(input_list$predicted_df) > 0) {
    predicted_df <- input_list$predicted_df
  } else {
    predicted_df <-
      selectedModelForecaster(selectedModel, selectedModelObject, allModelEvaluated)
  }

  y_axis_title <- trimws(unlist(strsplit(selectedModel, '[~]'))[[1]])

  ggplot(predicted_df, aes(lubridate::dmy(Date))) +

    geom_line(aes(y = predicted_values, colour = "Predicted")) +
    geom_line(aes(y = get(y_axis_title), colour = "Actuals")) + xlab("Date") + ylab(y_axis_title) +
    ggtitle(paste0("Model results for ", selectedModel)) + theme(plot.title = element_text(size =  8, hjust = 0.5))
}



#' Chart the scenarios predictions 
#'
#' @param scenariosList list containing all scenarios with scenario names and predictions 
#' @return Returns ggplot
#' @export
#' @examples
#' selectedModelScenariosCharter(scenariosList,baseline_predictions)

selectedModelScenariosCharter <- function(scenariosList,baseline_predictions,...) {
  # input_list <- as.list(substitute(list(...)))
  input_arg_list <- list(...)

  setDT(baseline_predictions)
  setnames(baseline_predictions,'predicted_values','baseline')
  all_predictions<-baseline_predictions[,c("Date",'baseline')]
  all_scenario_names<-c()
  for (scenario in scenariosList) {
    scenario_name<-scenario@scenario_name
    scenario_predictions=scenario@predictions
    setDT(scenario_predictions)
    scenario_predictions<-scenario_predictions[,c("Date",'predicted_values')]
    all_predictions<-all_predictions[scenario_predictions,on='Date']
    setnames(all_predictions,'predicted_values',scenario_name)
    all_scenario_names<-c(all_scenario_names,scenario_name)
  }
  # ODR <- trimws(unlist(strsplit(selectedModel, '[~]'))[[1]])
  plot_data<-melt(all_predictions,id.vars ='Date',variable.name = 'scenario',value.name = 'predictions')

  if ("scenario_colors" %in% names(input_arg_list)) {
    scenario_colors <- c(input_arg_list$scenario_colors,'gray')
    colors<- c('green','blue','red')
    names(scenario_colors) <- c(all_scenario_names,'baseline')
    p<-ggplot(plot_data,aes(x = lubridate::dmy(Date),y = predictions,color = scenario)) + scale_colour_manual(values=scenario_colors)+ geom_line()  + xlab("Time") +ggtitle(paste0("Scenario predictions ")) + theme(plot.title = element_text(size =  8, hjust = 0.5))
  } else {
    p<-ggplot(plot_data,aes(x = lubridate::dmy(Date),y = predictions,color = scenario)) +  geom_line() + xlab("Time")
      ggtitle(paste0("Scenario predictions ")) + theme(plot.title = element_text(size =  8, hjust = 0.5))
  }
  return(p)
  

}

#' Sensitivity analyser
#'
#' @param selectedModel model name as a string as generated by the function modelDeveloper. String can be stored in a vector and used as well
#' @param selectedModelObject the results as generated by modelEvaluator function
#' @param predicted_df the results as generated from model predictor in baseline
#' @param sensitivity the sensitivity inputs from user, if not provided would default to plus minus 5%
#' @param rhs the vector of macrovariables that are to be sensitised
#' @return Returns a list of dataframe with predicted values from different sensitivites of input
#' @export
#' @examples
#' ModelSensitiser(selectedModel,allModelEvaluated)

ModelSensitiser <- function(selectedModel,selectedModelObject,predicted_df,sensitivity,rhs,forecast_df,...){

  used_vars <- trimws(unlist(strsplit(selectedModel,"[+,~]")))
  if(length(sensitivity)==0){
    for(r in rhs){
      sensitivity[r]=0.05
    }
  }

  input_arg_list <- list(...)
  if ("transformedObj" %in% names(input_arg_list)) {
    transformedObj <- input_arg_list$transformedObj
  }
  # if (!is.na(transformedObj))
  # {
  #   keep_vars<- c("Date",used_vars,"predicted_base","input_down","input_up","predicted_down","predicted_up") 
  # } else {
  # }
  mev_sensitivity_df_list=list()
  mevs_sensitivity= sensitivity[names(sensitivity) %in% rhs] # use the sensitivity for ones that are present in the model
  for(mev in names(mevs_sensitivity)){
    #allModelEvaluated is not needed, to remove from this function as well as charter
    ### Upwards sensitivity
    sensitivity_input <-copy(predicted_df)
    predicted_base<-sensitivity_input$predicted_values
    setDT(sensitivity_input)
    s =sensitivity[mev]
    sensitivity_input[,c(mev):=.SD*(1+s),.SDcols = mev]
    predicted_up <- predict(selectedModelObject,newdata = sensitivity_input)

    input_up<-sensitivity_input[[mev]]
    
    ### Downwards sensitivity
    sensitivity_input <-copy(predicted_df)
    setDT(sensitivity_input)
    s =sensitivity[mev]
    sensitivity_input[,c(mev):=.SD*(1-s),.SDcols = mev]
    predicted_down <- predict(selectedModelObject,newdata = sensitivity_input)

    input_down<-sensitivity_input[[mev]]
    
    ### untransform
    if (isS4(transformedObj)){
      # number_of_elements_to_be_removed<-(transformedObj@differenceOrder * transformedObj@lag)
      no_of_elements_to_be_removed_for_untransform <- transformedObj@no_of_elements_to_be_removed_for_untransform
      total_length=length(predicted_up) #predicted_up, predicted_down etc expected to have same length
      predicted_transformed_up <- untransform(transformedObj,predicted_up[(no_of_elements_to_be_removed_for_untransform+1):total_length])@inputData
      predicted_transformed_down <-untransform(transformedObj,predicted_down[(no_of_elements_to_be_removed_for_untransform+1):total_length])@inputData
      predicted_transformed_base <- untransform(transformedObj,predicted_base[(no_of_elements_to_be_removed_for_untransform+1):total_length])@inputData
      keep_vars <- c("Date",used_vars,"predicted_base","input_down","input_up","predicted_down","predicted_up","predicted_transformed_base","predicted_transformed_down","predicted_transformed_up") 
      stopifnot(dim(forecast_df)[1]==length(predicted_transformed_up))
      overall_mev_sensitivity <- data.table(cbind(forecast_df,input_down,input_up,predicted_base,predicted_down,predicted_up,predicted_transformed_base,predicted_transformed_down,predicted_transformed_up))[,..keep_vars]
    } else {
      keep_vars <- c("Date",used_vars,"predicted_base","input_down","input_up","predicted_down","predicted_up") 
      
      overall_mev_sensitivity <- data.table(cbind(forecast_df,input_down,input_up,predicted_base,predicted_down,predicted_up))[,..keep_vars]
      
      
    }
    comment(overall_mev_sensitivity)<-mev
    mev_sensitivity_df_list <-c(mev_sensitivity_df_list,list(overall_mev_sensitivity))
  }
  names(mev_sensitivity_df_list) <- names(mevs_sensitivity)

  
  return(mev_sensitivity_df_list)
}


#' Chart the scenarios MEVs 
#'
#' @param scenariosList list containing all scenarios with scenario names and predictions 
#' @return Returns ggplot
#' @export
#' @examples
#' selectedModelScenariosCharter(scenariosList,baseline_predictions)

selectedModelScenariosMEVCharter <- function(scenariosList,baseline_predictions,mevs,...) {
  # input_list <- as.list(substitute(list(...)))
  input_arg_list <- list(...)
  setDT(baseline_predictions)
  baseline_predictions[,scenario:='baseline']

  make_long_format<-function(x){
    x@predictions <- x@predictions[,scenario:=x@scenario_name]
    return(x@predictions)
  }
  all_scenarios_list<-lapply(scenariosList,make_long_format)
  all_scenario_names<- lapply(scenariosList,function(x) x@scenario_name)

  plot_data <-rbindlist(all_scenarios_list)
  plot_data <-rbindlist(list(plot_data,baseline_predictions))
  # plot_data<-melt(all_scenarios_list,id.vars ='Date', measure.vars=mevs, variable.name = 'scenario',value.name = 'scenario_values')
  plotList =list()
  for (mev in mevs) {
    plot_cols <-c("Date",'scenario',mev)
    mev_col <-sym(mev)
    if ("scenario_colors" %in% names(input_arg_list)) {
      scenario_colors <- c(input_arg_list$scenario_colors,'gray')
      colors <- c('green','blue','red')
      names(scenario_colors) <- c(all_scenario_names,'baseline')
      p <- ggplot(plot_data,aes(x = lubridate::dmy(Date),y = !!mev_col,color = scenario)) + scale_colour_manual(values=scenario_colors)+ geom_line()  + xlab("Time") +ggtitle(paste0("Macrovariables across scenarios -",mev)) + theme(plot.title = element_text(size =  8, hjust = 0.5))
    } else {
      p <- ggplot(plot_data,aes(x = lubridate::dmy(Date),y = !!mev_col,color = scenario)) +  geom_line() + xlab("Time") + ggtitle(paste0("Macrovariables across scenarios - ",mev)) + theme(plot.title = element_text(size =  8, hjust = 0.5))
    }
    plotList <- append(plotList,list(p))
    
  }

  # 
  # n <- length(plotList)
  # nCol <- floor(sqrt(n))
  # plot_grid<-do.call("grid.arrange", c(plotList, ncol=2))
  return(plotList)
  
  
}
