#' Provides detailed diagnostic tests including tests for stationarity, autocorrelation for each model
#'
#' @param allModelObjects model Objects as generated by the function modelDeveloper
#' @param testData Test data to be provided as data.frame. If blank, it will look for test_df created by ValidationSampler in the Global environment.
#' @param direction_config To capture the expected sign of the coefficients of regression. This is a two column dataframe or datatable. Column names must be mandatorily 'Variable' and 'Type'. Variable contains the names of independent variables. Type denotes the expected relationship with response variable.It can take on either 1 or -1. If 1, indicates positive correlation, and hence expected signs of the coefficient is positive. If -1, indicates negative correlation, and hence expected signs of coefficients for those variables is negative
#' @return Results of various diagnostic tets of Stationarity, BP, DW, Tests of significance etc provided.
#' @export
#' @examples
#' modelDiagnostics(allModelObjects) # allModelObjects created by modelDeveloper()

modelDiagnostics <- function(allModelObjects,testData=test_df,direction_config=macrometa) {
  direction_check <- function(model_results,direction_config) {
    z <- as.data.table(coef(model_results), keep.rownames = TRUE)
    colnames(z) <- c("Variable", "coef")

    lookup <- direction_config$Type
    names(lookup) <- direction_config$Variable
    z$sign <- sign(z$coef)
    z$lookedup <- lookup[z$Variable]
    z<-z[z$Variable != "(Intercept)",]
    direction_check <- sum(z$sign==z$lookedup,na.rm=TRUE)/nrow(z)

    # direction_config<-as.data.table(direction_config)
    # signdf <- direction_config[z, on = c(Variable = "vars")]
    # signdf[Variable != "(Intercept)" , c("sign", "N") := list(ifelse(sign(coef) ==
    #                                                                    Type, TRUE, FALSE),
    #                                                           .N)]
    # direction_check <-
    #   sum(signdf$sign, na.rm = TRUE) / mean(signdf$N, na.rm = TRUE)
    return (direction_check) # 1 = 100% would mean all signs are intuitive

  }


  dfCoefNum   <- map_df(allModelObjects, function(x){

    df <- as.data.table(t(coef(x)))

  })

  dfdirectioncheck <- sapply(allModelObjects, function(x)
    direction_check(x,direction_config)
  )


  dfStdErrors <- map_df(allModelObjects, function(x) as.data.frame(
    t(coef(summary(x))[, "Std. Error"])))
  dftValues   <- map_df(allModelObjects, function(x) as.data.frame(
    t(coef(summary(x))[, "t value"])))
  dfpValues   <- map_df(allModelObjects, function(x) as.data.frame(
    t(coef(summary(x))[, "Pr(>|t|)"])))


  VIFValues <- map_df(allModelObjects,function(x) {
    coefficients <- names(x$coefficients)[!names(x$coefficients)== "(Intercept)" ]

    if (length(coefficients) < 2){
     #data.frame(paste0("VIF.",coefficients) = NA)
      vifs <- c(NA)
      names(vifs) <- paste0("VIF.",coefficients)
      as.data.frame(t(vifs))
    }
    else
    {
      vifs <- car::vif(x)
      names(vifs) <- paste0("VIF.",names(vifs))
       as.data.frame(t(vifs))
    }
  })

  names(dfStdErrors) <- paste("se", names(dfStdErrors), sep=".")
  names(dftValues) <- paste("t", names(dftValues), sep=".")
  names(dfpValues) <- paste("p", names(dfpValues), sep=".")

  calcPval <- function(x){
    fstat <- summary(x)$fstatistic
    pVal <- pf(fstat[1], fstat[2], fstat[3], lower.tail = FALSE)
    return(pVal)
  }

  #NoOfCoef <- unlist(apply(regMat, 1, sum))
  R2       <- sapply(allModelObjects, function(x)
    summary(x)$r.squared)
  adjR2    <- sapply(allModelObjects, function(x)
    summary(x)$adj.r.squared)
  RMSE     <- sapply(allModelObjects, function(x)
    summary(x)$sigma)
  fstats   <- sapply(allModelObjects, calcPval)


  MAPE_test <- sapply(allModelObjects, function(x) {
    df <-
      data.frame(DR = test_df$DR,
                 pred = predict(x, newdata = test_df)) # test data being used

    mean(abs((df$DR - df$pred) / df$DR) )
  })

  MAPE_training <- sapply(allModelObjects, function(x) {
    df <-
      data.frame(DR = train_df$DR,
                 pred = predict(x)) # training data being used

    mean(abs((df$DR - df$pred) / df$DR) )
  })
  #### BP tests
  bp_test_allModels <-
    lapply(allModelObjects,bptest)

  BP_statistic <-
    sapply(bp_test_allModels, function(x) x$statistic)

  BP_pvalue <- sapply(bp_test_allModels, function(x) x$p.value)


  ###DurbinWatson Tests
  dw_test_allModels <-
    lapply(allModelObjects, function(x)
      car::durbinWatsonTest(x))


  dw_statistic <- sapply(dw_test_allModels,function(x) x$dw)
  dw_p <- sapply(dw_test_allModels,function(x) x$p)



  ### Shapiro test test for Normality



  shapiro_test_allModels <-
    lapply(allModelObjects, function(x)
      shapiro.test(x$residuals))

  shapiro_statistic <-
    sapply(shapiro_test_allModels, function(x) x$statistic)
  shapiro_pvalue <-
    sapply(shapiro_test_allModels, function(x)  x$p.value)


  ## Unit Root Tests

  ADF_allModels <-
    lapply(allModelObjects, function(x)
      adf.test(x$residuals))


  adf_statistic <-
    sapply(ADF_allModels,function(x) x$statistic)


  adf_pvalue <-
    sapply(ADF_allModels, function(x) x$p.value)





  results <- data.table( model = as.character(names(allModelObjects)),
                         #NoOfCoef = NoOfCoef,
                         dfCoefNum,

                         dfStdErrors,
                         dftValues,
                         dfpValues,
                         VIFValues,
                         R2 = R2,
                         adjR2 = adjR2,
                         MAPE_test,
                         MAPE_training,
                         RMSE = RMSE,
                         pF = fstats,
                         BP_statistic,
                         BP_pvalue ,
                         dw_statistic ,
                         dw_pvalue = dw_p,
                         shapiro_statistic  ,
                         shapiro_pvalue  ,
                         adf_statistic ,
                         adf_pvalue ,
                         dfdirectioncheck
  )

  results_round <- as.data.table(lapply(results, function(x) {

    if (is.numeric(x)) round(x, 4) else (x)


  })
  )

  # Split into LHS and RHS

  results_round
  return(results_round)
}
